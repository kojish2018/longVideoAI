from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import List, Dict, Tuple


@dataclass
class Segment:
    abs_start: float
    abs_end: float
    lines: List[str]


def _format_ts(t: float) -> str:
    if t < 0:
        t = 0.0
    h = int(t // 3600)
    m = int((t % 3600) // 60)
    s = t % 60
    return f"{h:d}:{m:02d}:{s:05.2f}"


def _hex_color(color: str, default: str) -> str:
    # ASS expects BGR order with leading &H and trailing &
    # Here we assume already ASS format when startswith('&H'), otherwise hex like #RRGGBB
    c = (color or default).strip()
    if c.startswith("&H"):
        return c
    if c.startswith("#") and len(c) == 7:
        r = c[1:3]
        g = c[3:5]
        b = c[5:7]
        return f"&H00{b}{g}{r}&"
    return default


def _build_ass_header(layout: Dict) -> str:
    w = int(layout.get("canvas", {}).get("width", 1080))
    h = int(layout.get("canvas", {}).get("height", 1920))
    styles = layout.get("styles", {})

    def style_line(name: str, data: Dict) -> str:
        # Map JSON to ASS style fields
        f = {
            "Fontname": data.get("Fontname", "Noto Sans CJK JP"),
            "Fontsize": data.get("Fontsize", 54),
            "PrimaryColour": _hex_color(data.get("PrimaryColour", "&H00FFFFFF&"), "&H00FFFFFF&"),
            "SecondaryColour": _hex_color(data.get("SecondaryColour", "&H00000000&"), "&H00000000&"),
            "OutlineColour": _hex_color(data.get("OutlineColour", "&H00101010&"), "&H00101010&"),
            "BackColour": _hex_color(data.get("BackColour", "&H66000000&"), "&H66000000&"),
            "Bold": int(data.get("Bold", 0)),
            "Italic": int(data.get("Italic", 0)),
            "Underline": int(data.get("Underline", 0)),
            "StrikeOut": int(data.get("StrikeOut", 0)),
            "ScaleX": int(data.get("ScaleX", 100)),
            "ScaleY": int(data.get("ScaleY", 100)),
            "Spacing": int(data.get("Spacing", 0)),
            "Angle": int(data.get("Angle", 0)),
            "BorderStyle": int(data.get("BorderStyle", 3)),
            "Outline": int(data.get("Outline", 3)),
            "Shadow": int(data.get("Shadow", 0)),
            "Alignment": int(data.get("Alignment", 8)),
            "MarginL": int(data.get("MarginL", 60)),
            "MarginR": int(data.get("MarginR", 60)),
            "MarginV": int(data.get("MarginV", 1300)),
            "Encoding": int(data.get("Encoding", 1)),
        }
        wrap = int(data.get("WrapStyle", 2))
        return (
            f"Style: {name},{f['Fontname']},{f['Fontsize']},{f['PrimaryColour']},{f['SecondaryColour']},"
            f"{f['OutlineColour']},{f['BackColour']},{f['Bold']},{f['Italic']},{f['Underline']},{f['StrikeOut']},"
            f"{f['ScaleX']},{f['ScaleY']},{f['Spacing']},{f['Angle']},{f['BorderStyle']},{f['Outline']},{f['Shadow']},"
            f"{f['Alignment']},{f['MarginL']},{f['MarginR']},{f['MarginV']},{f['Encoding']},{wrap}"
        )

    lines = [
        "[Script Info]",
        "; Generated by typing_ass_builder.py",
        f"PlayResX: {w}",
        f"PlayResY: {h}",
        "WrapStyle: 2",
        "ScaledBorderAndShadow: yes",
        "",
        "[V4+ Styles]",
        "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding, WrapStyle",
        style_line("Typing", styles.get("Typing", {})),
        style_line("Title", styles.get("Title", {})),
        "",
        "[Events]",
        "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text",
    ]
    return "\n".join(lines)


def _segments_for_highlight_all(run_dir: Path, hl_start: float, hl_end: float) -> List[Segment]:
    """Collect segments across all scenes overlapping [hl_start, hl_end]."""
    tl = json.loads((run_dir / "timeline.json").read_text(encoding="utf-8"))
    scenes = sorted(tl.get("scenes", []), key=lambda s: float(s.get("start_time", 0.0)))
    segs: List[Segment] = []
    for scene in scenes:
        scene_id = scene.get("scene_id")
        scene_abs = float(scene.get("start_time", 0.0))
        audio_json = run_dir / "audio" / f"{scene_id}.json"
        if not audio_json.exists():
            continue
        seg_data = json.loads(audio_json.read_text(encoding="utf-8"))
        for seg in seg_data.get("segments", []):
            abs_s = scene_abs + float(seg.get("start_offset", 0.0))
            dur = float(seg.get("duration", 0.0))
            abs_e = abs_s + dur
            if abs_e <= hl_start or abs_s >= hl_end:
                continue
            lines = [ln.strip() for ln in seg.get("lines", []) if str(ln).strip()]
            segs.append(Segment(abs_start=abs_s, abs_end=abs_e, lines=lines))
    segs.sort(key=lambda s: s.abs_start)
    return segs


def _typing_text_for_duration(text: str, duration: float, layout: Dict) -> str:
    typing_cfg = layout.get("typing", {})
    min_char_ms = int(typing_cfg.get("min_char_ms", 20))
    max_char_ms = int(typing_cfg.get("max_char_ms", 80))
    min_chars = int(typing_cfg.get("min_chars_for_duration", 6))

    s = text
    if not s:
        return ""

    # Count characters (ASS \N remains as two chars in python but we keep as is)
    total_chars = max(len(s.replace("\n", "")), min_chars)
    dur_ms = max(int(duration * 1000), min_char_ms * total_chars)
    char_ms = max(min(dur_ms // total_chars, max_char_ms), min_char_ms)
    char_cs = max(char_ms // 10, 1)

    parts: List[str] = []
    for ch in s:
        if ch == "\n":
            parts.append("\\N")
        else:
            parts.append(f"{{\\kf{char_cs}}}{ch}")
    return "".join(parts)


def build_ass(
    *,
    script_title: str,
    run_dir: Path,
    hl_start: float,
    hl_end: float,
    layout_path: Path,
    out_path: Path,
) -> Dict:
    layout = json.loads(Path(layout_path).read_text(encoding="utf-8"))
    header = _build_ass_header(layout)
    segs = _segments_for_highlight_all(run_dir, hl_start, hl_end)
    if not segs:
        # produce title only
        duration = max(hl_end - hl_start, 1.0)
        events = [
            f"Dialogue: 0,{_format_ts(0)},{_format_ts(duration)},Title,,0,0,0,,{script_title}"
        ]
    else:
        duration = max(hl_end - hl_start, 0.1)
        events: List[str] = []
        # Title (always on for whole highlight)
        events.append(
            f"Dialogue: 0,{_format_ts(0)},{_format_ts(duration)},Title,,0,0,0,,{script_title}"
        )
        # Typing lines per overlapped segment
        for seg in segs:
            start_rel = max(seg.abs_start - hl_start, 0.0)
            end_rel = min(seg.abs_end - hl_start, duration)
            if end_rel <= start_rel:
                continue
            text = "\n".join(seg.lines)
            typed = _typing_text_for_duration(text, end_rel - start_rel, layout)
            events.append(
                f"Dialogue: 0,{_format_ts(start_rel)},{_format_ts(end_rel)},Typing,,0,0,0,,{typed}"
            )

    ass_text = header + "\n" + "\n".join(events) + "\n"
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(ass_text, encoding="utf-8")
    return {
        "duration": duration,
        "events": len(events),
        "layout": str(layout_path),
        "ass_path": str(out_path),
    }
