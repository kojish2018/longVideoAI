# FFmpeg最小移行計画

## ゴール
- MoviePy依存を保守フェーズに回しつつ、FFmpegベースのソフトウェアエンコード(x264)でレンダリング時間の短縮を図る。
- ハードウェアエンコーダ(VideoToolbox等)は後工程で検討し、今回の作業範囲から除外する。
- 既存パイプライン(LongFormPipeline)のインターフェースは維持し、設定スイッチでMoviePy版と切り替え可能にする。

## 方針
1. MoviePy版を即削除せず、新FFmpegレンダラーを並行実装する。
2. シーン単位で静止画+Ken Burns+字幕PNGをFFmpegフィルタで再現し、最終的に`concat`で結合する。
3. BGMループ/フェード/正規化はFFmpegフィルタ(`aloop`, `afade`, `loudnorm`等)で代替し、Python側は素材管理に専念する。
4. ログ出力は`logging_utils`経由で統一し、FFmpeg進捗の標準出力をINFOレベルに転送する。
5. 動作確認後にMoviePy→FFmpegの切り替えデフォルトを検討し、十分な検証が完了するまでは両実装を併存させる。

## タスク一覧
- 計測: 代表的なスクリプトでMoviePy版のレンダリング時間とログを記録 (`logs/`保管)。
- 設計: FFmpegフィルタグラフのテンプレートを定義(Ken Burns、字幕、音声ミックス)。
- 実装: 新モジュール(仮: `ffmpeg_renderer.py`)を追加し、`VideoGenerator`相当のAPIを再現。
- 連結: シーンごとの一時MP4生成→`concat`デマルチプレクサで本編を組み立てる処理を作成。
- 切替: 設定ファイルにレンダラー種別キーを追加し、`LongFormPipeline`終端で分岐。
- テスト: 同一素材でMoviePy版／FFmpeg版を比較し、時間短縮率と出力差異(画質・音量)を記録。
- ドキュメント: `requirements.md`や運用ガイドに新レンダラーの使い方と既知の制約を追記。

## 期待効果
- MoviePyで発生していたPython→FFmpeg間のフレーム転送待ち時間を解消し、3〜6倍程度のレンダリング短縮を目標とする。
- VideoToolbox等を使わなくてもCPUエンコーダがフルに稼働するため、1時間→10〜20分台への短縮が見込める。
- 実装規模を最小限に留めながら、後続でGPUエンコーダ対応やトランジション強化に拡張できる土台を整える。
